---
title: "What Language am I using for Advent of Code 2023?"
author: "Russell Waterhouse"
description: "This year I'm learning a new language with advent of code"
tags: ["Advent of Code 2023", "Programming", "Programming Languages"]
date: 2023-11-03T08:27:37-07:00
draft: false
---

# Advent of Code 2023

![](/post/images/advent_of_code.png)

## First, a Short Story

Pretend you're me, a few months from now. You log into work at the startup 
that employs you, and you start working on yesterday's ticket. By chance, you
log into aws console to test something. You notice something on your way to 
whatever service you needed to look at. 

```
COSTS UP 3482% COMPARED TO LAST MONTH
```

uhhh.... what? 

We should look at that.   
We should look at that now. 

`click click click`

Why has everything scaled so much? Our lambdas, our db cluster, everything? 
It's ... massive? 

Surely this is a mistake.  
You look at the most recent PR. It fixes typo in a translations file.   
You look at the second-most recent PR. It's clean too. 

So, DDOS then? But wait, no, we use cloudflare, we shouldn't get DDOS. 

Finally, you check google analytics. _Traffic is UP_

You check your analytics. Sales are up, new memberships are WAY UP. 

You check social media. Your biggest competitor went out of business, and
everyone is flocking to you and your service!

You've done it! You've actually done it! You and your team have 
crossed the infamous adoption chasm and it happened overnight! 

But your costs are still so high ...

And now you have to deal with it. You abandon whatever feature you were working
on and start profiling your product. You find 3 areas that are using WAY more 
compute and memory than they should. Dutifully, you start trying to optimize the
first one.

#### 1 Week Later...

Your growth is continuing much faster than you could ever hope to optimize this
ruby code. The day you've hoped for and feared is upon you. Nothing else makes
any sense to tackle this problem.  

You have to re-write it.  
Ruby just won't cut it. 
Neither will JavaScript, Neither will python.  
Java probably won't either, too much memory usage there.   
Go would work for the current traffic levels, but when will your growth stop?  
No, you need as much performance as possible. 

## Rust or C++?
What do you have to reach for when you need to build something big and fast? 
Right now, I currently have nothing, which is what I want to fix with Advent 
of Code this year. 
In the situation I described above, really only 2 things make sense in my head. 
C++ or Rust. I wouldn't want to fall back on my C knowledge from university. 
I would take far too long making strings. 

So, which one did I choose? Let's break it down. 

## Criteria
This decision, like any other, is going to be about tradeoffs. We can't evaluate
these tradeoffs without first defining criteria for what is good and what is bad. 

So, what is ideal in a fast non-garbage-collected language? 

1. Fast (Or else we wouldn't be choosing this language)
2. Feature complete
3. Good Development Tooling
3. Usable by industry
4. Prevents Errors

I'll explain the list briefly. 

### Fast
Now normally, I'm not a speed demon, and most of what I do doesn't need blazing
performance. However, these languages aren't for the everyday use case. We're 
not writing scripts with these languages, we're making things that require that
performance. This is the category of languages that we _need_ to be fast. 
If either Rust or C++ turns out to be not as fast as what we would expect, 
that would disqualify them from being chosen. 

### Feature Complete
I have no desire to program in a language that cannot yet open files or work
effectively with strings. Neither does the mass industry. You know, industry. 
The thing that pays for our groceries. We should listen to what it wants at 
least some of the time (although we should tell it to move on from Java 8.)
Like speed, this is a disqualifying criteria. Any language without feature
completeness is not one I will be using for advent of code. 

### Good Development Tooling
I also have no desire to program in a language without a good debugger, 
language server, IDE support, build system, package system, community-supported
packages, and the like. 

All of these make development fast. My hourly rate is very expensive, and I want
to deliver all that I can for that hourly rate. I don't want to spend hours
printf debugging when I could have spent 30 minutes in a debuggging session. 

Likewise, every time I get a red squiggly line in my editor telling me there 
is an error, it saves me a compile to check. Good updated packages served in a 
modern way are useful. Could you imagine writing a web backend from scratch in
ruby without rails? Me neither. 

### Usable by Industry
While I like learning just for the sake of learning, I also need to buy groceries
every month. For that reason, something that is used in industry is important to
me. The more something is used in industry, the more likely it is that I will
be paid for this skill. 

### Prevents Errors
I don't like writing bugs. It costs the company money in debugging and 
remediation time, and it costs the company money in lost users. If the langauge
can prevent me from doing something stupid, I'll take it every day. 

As a side note, this is why I'm a fan of explicit static types, TDD, and null
safety. Any guarantee that my code doesn't have bugs I will take.  

For example, I think the very best feature of Kotlin is adding nullability to the types in 
a way that makes a language that is nearly null-safe. I've written too much java
and fixed too many production `NullPointerException`'s to like the concept of null.

## Rust Evaluation
First, let's evaluate Rust by these criteria. 
I'm not going to be assigning hard numbers to these evaluations, after all 
this is just for advent of code. If this was an evaluation I was proposing 
in a technical report, the structure would be much more formal and the 
conclusions much more rigorous.

### Rust's Speed
Rust is a statically compiled language with no garbage collection. 
It is fast. 

Looking at some benchmarks that I found online, Rust is comparable in speed 
to C (which is about as fast as code can go). 

Full benchmarks can be found here: 
[https://programming-language-benchmarks.vercel.app/c-vs-rust](https://programming-language-benchmarks.vercel.app/c-vs-rust)

In any case, 

### Rust's Feature Completeness
Rust is feature complete. There isn't anything that I need a programming language
to do that Rust cannot. 

### Rust's Development Tooling
Rust has some good development tooling. Rust can be easily installed with 
the instructions at [https://rustup.rs/](https://rustup.rs/). It has a package
repository, [https://crates.io/](https://crates.io/), all managed by cargo, 
the package manager, build tool, and test tool, rolled into one. It all even
comes with docs at [https://docs.rs/](https://docs.rs/)

There is a language server, rust analyzer, a formatter, rustfmt,  and ...
clippy?  

Yes, they brought back clippy, and made him into a linter. Those mad lads 
at Rust have been busy I guess. 

From what I can see, many of the most popular rust crates (packages) are actively
maintained. This is very important for security reasons. Every unmaintained 
package that your project takes on as a dependency is a potential time bomb, 
and one that nobody else is going to defuse for you. 

Now, not that it's likely to matter for advent of code, since the programs are
so small, but I've seen online
that compilation time for Rust is quite long. If you're looking to build bigger
programs with it, this is probably something important to consider. 

Also, I can't see myself picking Rust for any embedded system right now, as 
the first tutorial I found for it seems to say that I need a nightly build of 
Rust and to clone some dude's github repo just to make an arduino uno work. 

Not great support in embedded.

### Rust's Industry Adoption



### Rust's Error Prevention
Rust appears to have some decent error prevention built in to the language. 
It has memory safety as a design feature, and that is something rare in this
space, since neither C++ nor C can technically offer that. 

That's very appealing to me. It's one thing to say we should just be better 
programmers and not leak our memory or overrun buffers, but it's another thing
to admit that we are fallable as people, and design a language with policies 
that take that into account.

Rust also has null safety in the form of the Option type, instead of nullable 
types. I like that a lot too. 

I take cybersecurity very seriously, and memory safety issues make up a massive
number of the vulnerabilities listed each year. Don't believe me? 

ZDNet reported in 2019 that 70% of Microsoft's vulnerabilitites were memory-related. 
How long has that trend lasted? 
  
12 years. 
Source: [https://www.zdnet.com/article/microsoft-70-percent-of-all-security-bugs-are-memory-safety-issues/](https://www.zdnet.com/article/microsoft-70-percent-of-all-security-bugs-are-memory-safety-issues/)

## C++ Evaluation

### C++'s Speed
### C++'s Feature Completeness
### C++'s Development Tooling
### C++'s Industry Adoption
### C++'s Error Prevention

## Evaluation Summary
Here we can see speed compared between C++ and Rust: 
[https://programming-language-benchmarks.vercel.app/cpp-vs-rust](https://programming-language-benchmarks.vercel.app/cpp-vs-rust)
Both are super close to each other, with most tests being within a few ms of 
each other. Both are plenty fast, so let's look at the other criteria. 

Like speed, both Rust and C++ are what I would consider to be feature complete.
Neither one of those criteria are what I expected to make this decision based
on, but it's good to have some criteria in there that disqualify options if they
aren't met. 

In development tooling, things get a little more interesting. Rust has Cargo
for package management, something that C++ is somewhat lacking. 

## The Winner

## Closing Thoughts
